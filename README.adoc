= Veigar
watertao <1059912278@qq.com>
:toc: left
:toclevels: 3
:source-highlighter: coderay
:sectnums:
:icons: font

:sectnumlevels: 3

一个用于开发 RESTful 接口的脚手架，基于 spring boot。

== 快速入门

=== 新建一个 Maven 项目

----
├── myapp
|   ├── src
|   |   └── main
|   |       ├── java
|   |       |   └── com
|   |       |       └── mycompany
|   |       |           └── BootstrapApplication.java
|   |       └── resources
|   |           └── application.properties
│   └── pom.xml
----

=== pom.xml

在 pom.xml 中引入 veigar 有两种方式：

==== 继承 veigar-parent

.pom.xml
[source, xml]
----
<parent>                                <!--1-->
  <groupId>io.github.watertao</groupId>
  <artifactId>veigar-parent</artifactId>
  <version>2.1.1-SNAPSHOT</version>
</parent>
<groupId>com.mycompy</groupId>
<artifactId>myapp</artifactId>
<version>1.0.0-SNAPSHOT</version>
----
<1> 继承 `veigar-parent`

==== 依赖 veigar-core

如果项目需要依赖其他 parent，无法依赖 `veigar-parent` ，那么可以通过以下方式达到同样的效果：

.pom.xml
[source, xml]
----
<groupId>com.mycompy</groupId>
<artifactId>myapp</artifactId>
<version>1.0.0-SNAPSHOT</version>
<dependencies>
  <dependency>                          <!--1-->
    <groupId>io.github.watertao</groupId>
    <artifactId>veigar-core</artifactId>
  </dependency>
</dependencies>
<build>
  <plugins>
    <plugin>                            <!--2-->
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-maven-plugin</artifactId>
    </plugin>
  </plugins>
</build>
----
<1> 依赖 `veigar-core`
<2> 添加插件 `spring-boot-maven-plugin`

=== BootstrapApplication.java

.BootstrapApplication.java
[source, java]
----
@SpringBootApplication(
   scanBasePackages={
      "com.mycompany",                  // <1>
      "io.github.watertao.veigar"
   }
)
public class BootstrapApplication {
   public static void main(String[] args) {
      SpringApplication.run(BootstrapApplication.class, args);
   }
}
----
<1> `@SpringBootApplication` 注解中 `scanBasePackages` 需要添加自己的项目 package，以及
 `io.github.watertao.veigar` ，这会告诉 spring 去扫描位于这些 package 下的 class 以便注册 bean。

[NOTE]
====
需要注意的是，`scanBasePackages` 中自己项目的 package 需要尽量设置到公司级别，比如上例中的
`com.mycompany` ，因为这会影响到组件的扫描范围。
====

=== application.properties

.application.properties
[source, properties]
----
spring.profiles.active = dev            # <1>
app.basePackage = com.mycompany.myapp   # <2>
server.port = 8080                      # <3>
cors.allowedOrigins = *                 # <4>
----
<1> 开发环境下设置为 `dev`， 生产环境下设置为 `prod`
<2> 项目级别的 package（公司级别下一级），某些组件需要读取并使用这个参数
<3> 服务端口
<4> CORS 允许的来源

=== 第一个接口

创建 src/main/java/com/mycompany/myapp/controller/TestController.java

.TestController.java
[source, java]
----
@RestController                         // <1>
public class TestController {
    @GetMapping("/test")                // <2>
    public Object test() {
        Map map.put("a", "b");
        return map;
    }
}
----
<1> 每个 RESTful 接口类都需要使用 `@RestController` 注解
<2> 每个 RESTful 接口方法都需要使用 `@RequestMapping` 或其子注解

=== 启动项目

通过执行 `spring-boot-maven-plugin` 启动项目：

[source, shell]
----
mvn spring-boot:run
----


== 设计理念

veigar 是在 spring boot 的基础上进一步封装了在开发 RESTful 接口时常用的一些特性，用于简化开发框架的搭建过程。 +
目前 veigar 支持的组件包括：

[cols="1,2,1", options="header"]
|===
|组件名
|作用
|依赖

|*veigar-parent*
|用于简化 pom.xml 中对 veigar 的依赖
|

|*veigar-core*
|核心组件
|

|*veigar-session*
|若项目具有用户会话的概念，就需要用到此组件。而此组件一般不单独依赖，还需要额外依赖一个 veigar-session-* 来指定会话持久化到哪里
|veigar-core

|*veigar-session-map*
|将会话保存在内存 Map 中
|veigar-session

|*veigar-session-redis*
|将会话保存在 redis 中
|veigar-session

|*veigar-db*
|若项目需要进行数据库访问，可以依赖此组件
|veigar-core

|*veigar-auth*
|提供了用户认证相关的扩展点
|veigar-session

|*veigar-audit-log*
|提供了用户日志审计相关的扩展点
|veigar-session

|===


== 特性

=== 基本 RESTful 支持

==== query parameter 获取

.HTTP REQUEST
----
GET /users?name=watertao HTTP/1.1
----

.controller
[source, java]
----
@GetMapping("/users")
public void test(
  @RequestParam("name") String name       // <1>
) {
    // name = "watertao";
}
----
<1> 使用 `@RequestParam` 获取 query parameter

==== path variable 获取

.HTTP REQUEST
----
GET /users/133 HTTP/1.1
----

.controller
[source, java]
----
@GetMapping("/users/{userId}")              // <1>
public void test(
  @PathVariable("userId") Integer userId    // <2>
) {
    // userId = 133;
}
----
<1> URI 的定义中需要指定 path variable 参数名，本例中为 `{userId}`
<2> 使用 `@PathVariable` 获取 path variable, 注解的参数需要与 URI 中 `{userId}` 内的定义相对应


==== request body 获取

.HTTP REQUEST
----
POST /users HTTP/1.1
Content-Type: application/json;charset=UTF-8

{
  "name": "watertao"
}
----

.controller
[source, java]
----
@PostMapping("/users")
public void test(
  @RequestBody User user                    // <1>
) {
    // user.getName() = "watertao"
}
----
<1> 使用 `@RequestBody` 注解告诉 spring boot 将 JSON 反序列化为对象

.User
[source, java]
----
public class User {
    private String name;
    public String getName() {...}
    public void setName(String name) {...}
}
----

==== Content-Type

veigar 只支持 JSON 格式，且字符集为 UTF-8 的请求。  +
所以，客户端在发起 RESTful 请求调用时，若请求体中包含了 JSON，则必须设置 `Content-Type` ：

.HTTP REQUEST
----
POST /users HTTP/1.1
Content-Type: application/json;charset=UTF-8

{ ... }
----


==== 请求校验

veigar 集成了 Hibernator-validator 作为 bean validation 的实现。所以我们可以很方便的对请求体中的 JSON 进行验证。

.User.java
[source, java]
----
public class User {
    @NotEmpty                                 // <1>
    private String name;

    public String getName() {...}

    public void setName(String name) {...}
}
----
<1> 通过注解 `@NotEmpty` 确保 `name` 属性不可为空


.controller
[source, java]
----
@PostMapping("/users")
public Object test(
  @Valid @RequestBody User user             // <1>
) {

}
----
<1> 通过添加注解 `@Valid` 告知 spring boot 对 `user` 对象进行校验，若 JSON 中 name 属性为空，则会抛出校验异常

bean validation 以及 hibernate-validator 所支持的校验注解可参考： +
https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#section-builtin-constraints[bean validation] +
https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#validator-defineconstraints-hv-constraints[hibernate validator]

==== CORS 跨域

在 `application.properties` 中添加以下配置可支持浏览器跨域访问：

.application.properties
[source, properties]
----
cors.allowedOrigins = http://localhost:8000
----

通过逗号分隔，可以支持多个域：

.application.properties
[source, properties]
----
cors.allowedOrigins = http://localhost:8000,http://10.10.10.10
----

或者通过 `*` 支持所有的域：

.application.properties
[source, properties]
----
cors.allowedOrigins = *
----


=== 日志打印

veigar 使用 `slf4j` + `logback` 来输出日志。 +
在 `application.properties` 中可以通过以下配置设置 root 的输出级别以及输出 pattern：

.application.properties
[source, properties]
----
logging.root.level = INFO                                                   # <1>
logging.encodePattern = %d{yyyy/MM/dd-HH:mm:ss SSS} %-5level - %msg %n      # <2>
----
<1> root 输出级别，缺省为 `INFO`
<2> 输出的 pattern，缺省为 `%d{yyyy/MM/dd-HH:mm:ss SSS} %-5level - %msg %n`

根据 `application.properties` 中的属性 `spring.profiles.active` 取值不同，日志输出的行为也会有所不同：

_dev_::
日志只会输出到控制台,不会输出到文件。

_prod_::
日志只会输出到文件，不会输出到控制台。 +
在这种模式下，veigar 还支持以下配置：

.application.properties
[source, properties]
----
logging.path = /Users/watertao/Temp/auditlog          # <1>
logging.file = myapp.log                              # <2>
logging.splitPattern = yyyy-MM-dd_HH                  # <3>
logging.maxHistory = 30                               # <4>
----
<1> 日志文件输出的目录，缺省为 jar 包所在的目录
<2> 日志文件的文件名，缺省为 spring.log
<3> 日志文件按时间切割的模式，缺省为 `yyyy-MM-dd` （即按天切割）
<4> 日志文件保存的文件个数，缺省为 30 个文件

日志输出 API 使用范例：

[source, java]
----
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class TestController {

  private static final Logger logger = LoggerFactory.getLogger(TestController.class);

  public void test() {
    logger.info("hello log");
  }

}
----

=== 请求日志

veigar 会打印所有 controller 的请求调用，看起来如下：

----
2019/01/10-13:13:19 141 INFO  - <--o POST /test
2019/01/10-13:13:19 142 INFO  - PAYLOAD: {"name":"test2"}
...
2019/01/10-13:13:19 142 INFO  - o--> COST: 1ms; PAYLOAD: {"name":"test2"}
----

如果觉得这种打印风格不满足需求，也可以实现 `io.github.watertao.veigar.core.reqlog.RequestLogger` 接口，
并将其注册为 spring bean 来替换默认风格。比如：

.MyRequestLogger.java
[source, java]
----
@Component
public class MyRequestLogger implements RequestLogger {

    private static final Logger logger = LoggerFactory.getLogger(MyRequestLogger.class);

    @Override
    public void preLog(HttpServletRequest request, Object requestBody) {
        logger.info("REQUEST RECEIVED:");
        logger.info("{} {}", request.getMethod(), request.getRequestUri());
    }

    @Override
    public void postLog(Object result, Throwable exception, Long cost) {
        logger.info("RESPONSE: {}", toJson(result));
    }
    private String toJson(Object obj) {...}
}
----

那么请求日志的输出将会变成：

----
2019/01/10-13:13:19 141 INFO  - REQUEST RECEIVED:
2019/01/10-13:13:19 142 INFO  - POST /test
...
2019/01/10-13:13:19 142 INFO  - RESPONSE: {"name":"test2"}
----


=== 异常处理

在 veigar 项目中，我们不必在 controller 中捕获异常并将其转化为 json。我们只需要直接抛出异常即可，
veigar 会将其转化为合适的 json。 +
veigar 提供了以下几个常用的运行时异常类：


[cols="1,2,1", options="header"]
|===
|异常类
|推荐使用场景
|HTTP 状态码

|*BadRequestException*
|当请求的参数有问题时，比如格式有误
|400

|*ForbiddenException*
|当请求被禁止访问时，比如 A 分公司的用户想要访问 B 分公司的数据，若是业务要求禁止，那么就可以抛出此类异常
|401

|*ConflictException*
|当资源与预期状态有冲突时，比如针对一个尚未测试的接口进行审核通过的请求调用，按照逻辑是不允许的，这时候就可以提示状态冲突。
|409

|*NotFoundException*
|访问了一个不存在的资源，比如对一个 ID为3的接口进行修改操作，而实际上库里并不存在 ID 为 3 的接口
|404

|*UnauthenticatedException*
|系统无法识别当前用户的时候。比如 session 过期，登录时密码错误等
|403

|*HttpStatusException*
|如果以上异常都不满足场景时，可使用此异常，并设定一个状态码即可。
|自定义

|*InternalServerException*
|提对于运行时产生的一些非预期异常，比如 NullPoint，数据库访问异常等，框架最终都被将其包装成此错误
|500

|===

任何异常最终都会被转成以下格式的 json：

[source, json]
----
{
    "status": 403,                      // <1>
    "error": "Forbidden",               // <2>
    "message": "未登录",                 // <3>
    "verbose": null                     // <4>
}
----
<1> 异常对应的状态码
<2> 状态码对应的标准描述语（与 HTTP 规范兼容）
<3> 自定义的异常描述
<4> 附加的异常描述补充

[NOTE]
====
对于客户端而言，状态码为 `2xx` ( 如 `200` / `201` / `204` ) 的响应就代表着请求的处理是成功的，非 `2xx` 的响应即代表处理失败。
====


=== 消息国际化

若要在 veigar 项目中使用消息国际化的特性，需要在 src/main/resources/message 下创建不同语言的
消息资源文件，下面以中文和英文为例：

----
├── myapp
|   ├── src
|   |   └── main
|   |       ├── java
|   |       └── resources
|   |           └── message
|   |               ├── message_en.properties           // <1>
|   |               └── message_zh.properties           // <2>
│   └── pom.xml
----
<1> 英文消息资源文件
<2> 中文消息资源文件

分别为两个资源文件添加属性名为 `test.name` 的消息：

.message_en.properties
[source, properties]
----
test.name = I'm English
----

.message_zh.properties
[source, properties]
----
test.name = 我是中文的
----

在需要国际化消息的地方，可以通过注入 `io.github.watertao.veigar.core.message.LocaleMessage` 来使用：

[source, java]
----
@Component
public class Test {

    @Autowired
    private LocaleMessage localeMessage;                          // <1>

    public void test() {
        System.out.println(localeMessage.m("test.name"));         // <2>
    }

}
----
<1> 注入 LocaleMessage bean
<2> 调用 localeMessage 的 m 方法，将消息属性名作为参数传入即可

veigar 会根据 HTTP 请求头部中的 `Accept-Language` 来决定使用哪种语言的消息资源文件。


=== 数据库访问

访问数据库是绝大部分项目的需求，我们需要添加组件 `veigar-db` 的依赖；

.pom.xml
[source, xml]
----
<dependency>
    <groupId>io.github.watertao</groupId>
    <artifactId>veigar-db</artifactId>
    <version>2.1.1-SNAPSHOT</version>
</dependency>
----

veigar-db 使用 mybatis 作为 ORM 框架， 使用 druid 作为连接池。 +
下面以 mysql 为例，描述如何使项目支持数据库访问。 +
除了上面的 `veigar-db` ，我们还需要添加 jdbc 驱动的依赖：

.pom.xml
[source, xml]
----
<dependency>
     <groupId>mysql</groupId>
     <artifactId>mysql-connector-java</artifactId>
     <version>5.1.47</version>
</dependency>
----

在 `application.properties` 中添加数据库相关的配置：

.application.properties
[source, properties]
----
spring.datasource.driverClassName = com.mysql.jdbc.Driver
spring.datasource.url = jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8&zeroDateTimeBehavior=convertToNull
spring.datasource.username = test
spring.datasource.password = test
spring.datasource.maxActive = 20          # <1>
----
<1> 连接池的最大连接数

做完了以上这些工作，我们就可以在项目中使用 mybatis 进行开发了。

==== Mapper 接口

Mapper 接口可以放在项目 package ( `com.mycompany.myapp` ) 下的任意目录中，veigar 通过
`@Mapper` 注解来识别 Mapper 接口：

[source, java]
----
@Mapper       // <1>
public interface TestMapper {
    int insertTest(Test test);
}
----
<1> `@Mapper` 注解

==== Mapper XML 映射文件

映射文件 *必须* 放在 src/main/resources/mybatis/mapper 文件夹下：

----
├── myapp
|   ├── src
|   |   └── main
|   |       ├── java
|   |       └── resources
|   |           └── mybatis
|   |               └── mapper
|   |                   ├── Test1Mapper.xml
|   |                   └── Test2Mapper.xml
│   └── pom.xml
----

==== 在 service 中使用 mapper

veigar 会扫描带有 `@Mapper` 的接口，并将其注册为 bean，service 类中我们可以注入 mapper 进行
数据库访问：

[source, java]
----
@Service
public class TestService {
    @Autowired
    private TestMapper testMapper;
}
----

==== 数据库事务

veigar 使用了基于注解的事务，因此在 service 类中我们得给需要事务的方法添加 `@Transactional` 注解：

[source, java]
----
@Service
public class TestService {
    @Transactional
    public void doTest() {
        ...
    }
}
----

==== 自动生成 Mapper

对数据库表的简单增删改查，我们可以通过 Mybatis-generator ( mbg ) 来自动生成 Mapper 接口，
Model 以及 映射文件。 +
首先需要在 pom.xml 中添加 mbg 插件的依赖：

.pom.xml
[source, xml]
----
<build>
 <plugins>
  <plugin>
   <groupId>org.mybatis.generator</groupId>
   <artifactId>mybatis-generator-maven-plugin</artifactId>
   <version>1.3.7</version>
   <configuration>
    <configurationFile>mbg/generatorConfig.xml</configurationFile>
   </configuration>
  </plugin>
 </plugins>
</build>
----

在项目根目录下新建 mbg 相关目录及 generatorConfig.xml 配置文件：

----
├── myapp
|   ├── mbg
|   |   ├── output
|   |   └── generatorConfig.xml
|   ├── src
│   └── pom.xml
----

.generatorConfig.xml
[source, XML]
----
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE generatorConfiguration
  PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
  "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">
<generatorConfiguration>
  <properties resource="application.properties" ></properties>
  <classPathEntry location="/Users/watertao/.m2/repository/mysql/mysql-connector-java/5.1.47/mysql-connector-java-5.1.47.jar" />    <!--1-->
  <context id="mbgTables" targetRuntime="MyBatis3">
    <plugin type="org.mybatis.generator.plugins.MapperAnnotationPlugin"></plugin>
    <commentGenerator>
      <property name="suppressAllComments" value="true"/>
    </commentGenerator>
    <jdbcConnection driverClass="${spring.datasource.driverClassName}"
                    connectionURL="${spring.datasource.url}"
                    userId="${spring.datasource.username}"
                    password="${spring.datasource.password}">
    </jdbcConnection>
    <javaTypeResolver>
      <property name="forceBigDecimals" value="false"/>
    </javaTypeResolver>
    <javaModelGenerator targetPackage="${app.basePackage}.model" targetProject="mbg/output/">
      <property name="enableSubPackages" value="true"/>
      <property name="trimStrings" value="true"/>
    </javaModelGenerator>
    <sqlMapGenerator targetPackage="mapper" targetProject="mbg/output/">
      <property name="enableSubPackages" value="true"/>
    </sqlMapGenerator>
    <javaClientGenerator type="XMLMAPPER" targetPackage="${app.basePackage}.mapper.autogen" targetProject="mbg/output/">
      <property name="enableSubPackages" value="true"/>
    </javaClientGenerator>
    <table schema="test" tableName="test" enableSelectByExample="true" enableDeleteByExample="true"
           enableCountByExample="true" enableUpdateByExample="true">        <!--2-->
    </table>
  </context>
</generatorConfiguration>
----
<1> 开发环境本地的 jdbc 驱动绝对路径
<2> 需要生成的表

我们可以复制以上内容到 generatorConfig.xml 文件，设置好 jdbc 驱动的位置，添加所需要生成的表，接着执行以下命令：

----
mvn mybatis-generator:generate
----

执行成功后，在 myapp/mbg/output 目录下会生成相应的文件，然后我们将他们拷贝到 myapp/src/main 下对应的位置即可。

[TIP]
====
为了避免自动生成的文件覆盖掉手动修改过的文件，强烈建议将自动生成的和手工生成的分别放在不同的目录中，我们可以
在 com.mycompany.myapp.mapper 下建立 autogen 和 custom 包， 在 resources/mybatis/mapper 下建立
autogen 和 custom 文件夹，最终的目录结构看起来如下：

----
├── myapp
|   ├── mbg
|   ├── src
|   |   └── main
|   |       ├── java
|   |       |   └── com
|   |       |       └── mycompany
|   |       |           └── myapp
|   |       |               ├── mapper
|   |       |               |   ├── autogen    // <1>
|   |       |               |   └── custom     // <2>
|   |       |               └── model          // <3>
|   |       └── resources
|   |           ├── autogen                    // <4>
|   |           └── custom                     // <5>
│   └── pom.xml
----
<1> 存放 mbg 自动生成的 mapper 接口
<2> 存放手工编写的 mapper 接口
<3> 存放自动生成的 model
<4> 存放 mbg 自动生成的 mapper 映射文件
<5> 存放手工编写的 mapper 映射文件

====

=== 会话（ Session ）支持

如果项目涉及到用户，那么就需要支持会话，在 veigar 使用会话需要在 pom 中添加组件 `veigar-session` 的依赖：

.pom.xml
[source, XML]
----
<dependency>
    <groupId>io.github.watertao</groupId>
    <artifactId>veigar-session</artifactId>
    <version>2.1.1-SNAPSHOT</version>
</dependency>
----

同时还需要依赖一个会话序列化的实现组件，veigar 目前提供了两种方案：

_序列化至内存_::
对于简单的项目，我们完全可以将 session 保存在 jvm 内存中，采用这种方式需要添加依赖：

.pom.xml
[source, XML]
----
<dependency>
    <groupId>io.github.watertao</groupId>
    <artifactId>veigar-session-map</artifactId>
    <version>2.1.1-SNAPSHOT</version>
</dependency>
----
这种方式虽然简单，但会有两个弊端：+
首先，负载均衡时无法做到多个应用间共享 session +
其次，应用重启后，session 将丢失


_序列化至 redis_::
对于需要负载均衡的项目，我们往往会将会话保存在外部缓存中，比如 redis，采用这种方式需要添加依赖：

.pom.xml
[source, XML]
----
<dependency>
    <groupId>io.github.watertao</groupId>
    <artifactId>veigar-session-redis</artifactId>
    <version>2.1.1-SNAPSHOT</version>
</dependency>
----

同时我们需要在 `application.properties` 中添加 redis 的连接配置：

.application.properties
[source, properties]
----
spring.redis.host = localhost
spring.redis.port = 6379
----

[NOTE]
====
需要注意的是，Session 的序列化实现组件只能依赖一个，也就是说不能同时依赖 `veigar-session-map`
和 `veigar-session.redis`
====
