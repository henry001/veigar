= Veigar
watertao <1059912278@qq.com>
:toc: left
:toclevels: 3
:source-highlighter: coderay
:sectnums:
:icons: font

:sectnumlevels: 3

一个用于开发 RESTful 接口的脚手架，基于 spring boot。

== 快速入门

=== 新建一个 Maven 项目

----
├── myapp
|   ├── src
|   |   └── main
|   |       ├── java
|   |       |   └── com
|   |       |       └── mycompany
|   |       |           └── BootstrapApplication.java
|   |       └── resources
|   |           └── application.properties
│   └── pom.xml
----

=== pom.xml

在 pom.xml 中引入 veigar 有两种方式：

==== 继承 veigar-parent

.pom.xml
[source, xml]
----
<parent>                                <!--1-->
  <groupId>io.github.watertao</groupId>
  <artifactId>veigar-parent</artifactId>
  <version>2.1.1-SNAPSHOT</version>
</parent>
<groupId>com.mycompy</groupId>
<artifactId>myapp</artifactId>
<version>1.0.0-SNAPSHOT</version>
----
<1> 继承 `veigar-parent`

==== 依赖 veigar-core

如果项目需要依赖其他 parent，无法依赖 `veigar-parent` ，那么可以通过以下方式达到同样的效果：

.pom.xml
[source, xml]
----
<groupId>com.mycompy</groupId>
<artifactId>myapp</artifactId>
<version>1.0.0-SNAPSHOT</version>
<dependencies>
  <dependency>                          <!--1-->
    <groupId>io.github.watertao</groupId>
    <artifactId>veigar-core</artifactId>
  </dependency>
</dependencies>
<build>
  <plugins>
    <plugin>                            <!--2-->
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-maven-plugin</artifactId>
    </plugin>
  </plugins>
</build>
----
<1> 依赖 `veigar-core`
<2> 添加插件 `spring-boot-maven-plugin`

=== BootstrapApplication.java

.BootstrapApplication.java
[source, java]
----
@SpringBootApplication(
   scanBasePackages={
      "com.mycompany",                  // <1>
      "io.github.watertao.veigar"
   }
)
public class BootstrapApplication {
   public static void main(String[] args) {
      SpringApplication.run(BootstrapApplication.class, args);
   }
}
----
<1> `@SpringBootApplication` 注解中 `scanBasePackages` 需要添加自己的项目 package，以及
 `io.github.watertao.veigar` ，这会告诉 spring 去扫描位于这些 package 下的 class 以便注册 bean。

[NOTE]
====
需要注意的是，`scanBasePackages` 中自己项目的 package 需要尽量设置到公司级别，比如上例中的
`com.mycompany` ，因为这会影响到组件的扫描范围。
====

=== application.properties

.application.properties
[source, properties]
----
spring.profiles.active = dev            # <1>
app.basePackage = com.mycompany.myapp   # <2>
server.port = 8080                      # <3>
cors.allowedOrigins = *                 # <4>
----
<1> 开发环境下设置为 `dev`， 生产环境下设置为 `prod`
<2> 项目级别的 package（公司级别下一级），某些组件需要读取并使用这个参数
<3> 服务端口
<4> CORS 允许的来源

=== 第一个接口

创建 src/main/java/com/mycompany/myapp/controller/TestController.java

.TestController.java
[source, java]
----
@RestController                         // <1>
public class TestController {
    @GetMapping("/test")                // <2>
    public Object test() {
        Map map.put("a", "b");
        return map;
    }
}
----
<1> 每个 RESTful 接口类都需要使用 `@RestController` 注解
<2> 每个 RESTful 接口方法都需要使用 `@RequestMapping` 或其子注解

=== 启动项目

通过执行 `spring-boot-maven-plugin` 启动项目：

[source, shell]
----
mvn spring-boot:run
----


== 设计理念

veigar 是在 spring boot 的基础上进一步封装了在开发 RESTful 接口时常用的一些特性，用于简化开发框架的搭建过程。 +
目前 veigar 支持的组件包括：

[cols="1,2,1", options="header"]
|===
|组件名
|作用
|依赖

|*veigar-parent*
|用于简化 pom.xml 中对 veigar 的依赖
|

|*veigar-core*
|核心组件
|

|*veigar-session*
|若项目具有用户会话的概念，就需要用到此组件。而此组件一般不单独依赖，还需要额外依赖一个 veigar-session-* 来指定会话持久化到哪里
|veigar-core

|*veigar-session-map*
|将会话保存在内存 Map 中
|veigar-session

|*veigar-session-redis*
|将会话保存在 redis 中
|veigar-session

|*veigar-db*
|若项目需要进行数据库访问，可以依赖此组件
|veigar-core

|*veigar-auth*
|提供了用户认证相关的扩展点
|veigar-session

|*veigar-audit-log*
|提供了用户日志审计相关的扩展点
|veigar-session

|===


== 特性

=== 基本 RESTful 支持

==== query parameter 获取

.HTTP REQUEST
----
GET /users?name=watertao HTTP/1.1
----

.controller
[source, java]
----
@GetMapping("/users")
public void test(
  @RequestParam("name") String name       // <1>
) {
    // name = "watertao";
}
----
<1> 使用 `@RequestParam` 获取 query parameter

==== path variable 获取

.HTTP REQUEST
----
GET /users/133 HTTP/1.1
----

.controller
[source, java]
----
@GetMapping("/users/{userId}")              // <1>
public void test(
  @PathVariable("userId") Integer userId    // <2>
) {
    // userId = 133;
}
----
<1> URI 的定义中需要指定 path variable 参数名，本例中为 `{userId}`
<2> 使用 `@PathVariable` 获取 path variable, 注解的参数需要与 URI 中 `{userId}` 内的定义相对应


==== request body 获取

.HTTP REQUEST
----
POST /users HTTP/1.1
Content-Type: application/json;charset=UTF-8

{
  "name": "watertao"
}
----

.controller
[source, java]
----
@PostMapping("/users")
public void test(
  @RequestBody User user                    // <1>
) {
    // user.getName() = "watertao"
}
----
<1> 使用 `@RequestBody` 注解告诉 spring boot 将 JSON 反序列化为对象

.User
[source, java]
----
public class User {
    private String name;
    public String getName() {...}
    public void setName(String name) {...}
}
----

==== Content-Type

veigar 只支持 JSON 格式，且字符集为 UTF-8 的请求。  +
所以，客户端在发起 RESTful 请求调用时，若请求体中包含了 JSON，则必须设置 `Content-Type` ：

.HTTP REQUEST
----
POST /users HTTP/1.1
Content-Type: application/json;charset=UTF-8

{ ... }
----


==== 请求校验

veigar 集成了 Hibernator-validator 作为 bean validation 的实现。所以我们可以很方便的对请求体中的 JSON 进行验证。

.User.java
[source, java]
----
public class User {
    @NotEmpty                                 // <1>
    private String name;

    public String getName() {...}

    public void setName(String name) {...}
}
----
<1> 通过注解 `@NotEmpty` 确保 `name` 属性不可为空


.controller
[source, java]
----
@PostMapping("/users")
public Object test(
  @Valid @RequestBody User user             // <1>
) {

}
----
<1> 通过添加注解 `@Valid` 告知 spring boot 对 `user` 对象进行校验，若 JSON 中 name 属性为空，则会抛出校验异常

bean validation 以及 hibernate-validator 所支持的校验注解可参考： +
https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#section-builtin-constraints[bean validation] +
https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#validator-defineconstraints-hv-constraints[hibernate validator]

==== CORS 跨域

在 `application.properties` 中添加以下配置可支持浏览器跨域访问：

.application.properties
[source, properties]
----
cors.allowedOrigins = http://localhost:8000
----

通过逗号分隔，可以支持多个域：

.application.properties
[source, properties]
----
cors.allowedOrigins = http://localhost:8000,http://10.10.10.10
----

或者通过 `*` 支持所有的域：

.application.properties
[source, properties]
----
cors.allowedOrigins = *
----


=== 日志打印

veigar 使用 `slf4j` + `logback` 来输出日志。 +
在 `application.properties` 中可以通过以下配置设置 root 的输出级别以及输出 pattern：

.application.properties
[source, properties]
----
logging.root.level = INFO                                                   # <1>
logging.encodePattern = %d{yyyy/MM/dd-HH:mm:ss SSS} %-5level - %msg %n      # <2>
----
<1> root 输出级别，缺省为 `INFO`
<2> 输出的 pattern，缺省为 `%d{yyyy/MM/dd-HH:mm:ss SSS} %-5level - %msg %n`

根据 `application.properties` 中的属性 `spring.profiles.active` 取值不同，日志输出的行为也会有所不同：

_dev_::
日志只会输出到控制台,不会输出到文件。

_prod_::
日志只会输出到文件，不会输出到控制台。 +
在这种模式下，veigar 还支持以下配置：

.application.properties
[source, properties]
----
logging.path = /Users/watertao/Temp/auditlog          # <1>
logging.file = myapp.log                              # <2>
logging.splitPattern = yyyy-MM-dd_HH                  # <3>
logging.maxHistory = 30                               # <4>
----
<1> 日志文件输出的目录，缺省为 jar 包所在的目录
<2> 日志文件的文件名，缺省为 spring.log
<3> 日志文件按时间切割的模式，缺省为 `yyyy-MM-dd` （即按天切割）
<4> 日志文件保存的文件个数，缺省为 30 个文件

日志输出 API 使用范例：

[source, java]
----
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class TestController {

  private static final Logger logger = LoggerFactory.getLogger(TestController.class);

  public void test() {
    logger.info("hello log");
  }

}
----

=== 请求日志

veigar 会打印所有 controller 的请求调用，看起来如下：

----
2019/01/10-13:13:19 141 INFO  - <--o POST /test
2019/01/10-13:13:19 142 INFO  - PAYLOAD: {"name":"test2"}
...
2019/01/10-13:13:19 142 INFO  - o--> COST: 1ms; PAYLOAD: {"name":"test2"}
----

如果觉得这种打印风格不满足需求，也可以实现 `io.github.watertao.veigar.core.reqlog.RequestLogger` 接口，
并将其注册为 spring bean 来替换默认风格。比如：

.MyRequestLogger.java
[source, java]
----
@Component
public class MyRequestLogger implements RequestLogger {

    private static final Logger logger = LoggerFactory.getLogger(MyRequestLogger.class);

    @Override
    public void preLog(HttpServletRequest request, Object requestBody) {
        logger.info("REQUEST RECEIVED:");
        logger.info("{} {}", request.getMethod(), request.getRequestUri());
    }

    @Override
    public void postLog(Object result, Throwable exception, Long cost) {
        logger.info("RESPONSE: {}", toJson(result));
    }
    private String toJson(Object obj) {...}
}
----

那么请求日志的输出将会变成：

----
2019/01/10-13:13:19 141 INFO  - REQUEST RECEIVED:
2019/01/10-13:13:19 142 INFO  - POST /test
...
2019/01/10-13:13:19 142 INFO  - RESPONSE: {"name":"test2"}
----


=== 异常处理

在 veigar 项目中，我们不必在 controller 中捕获异常并将其转化为 json。我们只需要直接抛出异常即可，
veigar 会将其转化为合适的 json。 +
veigar 提供了以下几个常用的运行时异常类：


[cols="1,2,1", options="header"]
|===
|异常类
|推荐使用场景
|HTTP 状态码

|*BadRequestException*
|当请求的参数有问题时，比如格式有误
|400

|*ForbiddenException*
|当请求被禁止访问时，比如 A 分公司的用户想要访问 B 分公司的数据，若是业务要求禁止，那么就可以抛出此类异常
|401

|*ConflictException*
|当资源与预期状态有冲突时，比如针对一个尚未测试的接口进行审核通过的请求调用，按照逻辑是不允许的，这时候就可以提示状态冲突。
|409

|*NotFoundException*
|访问了一个不存在的资源，比如对一个 ID为3的接口进行修改操作，而实际上库里并不存在 ID 为 3 的接口
|404

|*UnauthenticatedException*
|系统无法识别当前用户的时候。比如 session 过期，登录时密码错误等
|403

|*HttpStatusException*
|如果以上异常都不满足场景时，可使用此异常，并设定一个状态码即可。
|自定义

|*InternalServerException*
|提对于运行时产生的一些非预期异常，比如 NullPoint，数据库访问异常等，框架最终都被将其包装成此错误
|500

|===

任何异常最终都会被转成以下格式的 json：

[source, json]
----
{
    "status": 403,                      // <1>
    "error": "Forbidden",               // <2>
    "message": "未登录",                 // <3>
    "verbose": null                     // <4>
}
----
<1> 异常对应的状态码
<2> 状态码对应的标准描述语（与 HTTP 规范兼容）
<3> 自定义的异常描述
<4> 附加的异常描述补充

[NOTE]
====
对于客户端而言，状态码为 `2xx` ( 如 `200` / `201` / `204` ) 的响应就代表着请求的处理是成功的，非 `2xx` 的响应即代表处理失败。
====


=== 消息国际化

若要在 veigar 项目中使用消息国际化的特性，需要在 src/main/resources/message 下创建不同语言的
消息资源文件，下面以中文和英文为例：

----
├── myapp
|   ├── src
|   |   └── main
|   |       ├── java
|   |       └── resources
|   |           └── message
|   |               ├── message_en.properties           // <1>
|   |               └── message_zh.properties           // <2>
│   └── pom.xml
----
<1> 英文消息资源文件
<2> 中文消息资源文件

分别为两个资源文件添加属性名为 `test.name` 的消息：

.message_en.properties
[source, properties]
----
test.name = I'm English
----

.message_zh.properties
[source, properties]
----
test.name = 我是中文的
----

在需要国际化消息的地方，可以通过注入 `io.github.watertao.veigar.core.message.LocaleMessage` 来使用：

[source, java]
----
@Component
public class Test {

    @Autowired
    private LocaleMessage localeMessage;                          // <1>

    public void test() {
        System.out.println(localeMessage.m("test.name"));         // <2>
    }

}
----
<1> 注入 LocaleMessage bean
<2> 调用 localeMessage 的 m 方法，将消息属性名作为参数传入即可

veigar 会根据 HTTP 请求头部中的 `Accept-Language` 来决定使用哪种语言的消息资源文件。


=== 数据库访问

访问数据库是绝大部分项目的需求，我们需要添加组件 `veigar-db` 的依赖；

.pom.xml
[source, xml]
----
<dependency>
    <groupId>io.github.watertao</groupId>
    <artifactId>veigar-db</artifactId>
    <version>2.1.1-SNAPSHOT</version>
</dependency>
----

veigar-db 使用 mybatis 作为 ORM 框架， 使用 druid 作为连接池。 +
下面以 mysql 为例，描述如何使项目支持数据库访问。 +
除了上面的 `veigar-db` ，我们还需要添加 jdbc 驱动的依赖：

.pom.xml
[source, xml]
----
<dependency>
     <groupId>mysql</groupId>
     <artifactId>mysql-connector-java</artifactId>
     <version>5.1.47</version>
</dependency>
----

在 `application.properties` 中添加数据库相关的配置：

.application.properties
[source, properties]
----
spring.datasource.driverClassName = com.mysql.jdbc.Driver
spring.datasource.url = jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8&zeroDateTimeBehavior=convertToNull
spring.datasource.username = test
spring.datasource.password = test
spring.datasource.maxActive = 20          # <1>
----
<1> 连接池的最大连接数

做完了以上这些工作，我们就可以在项目中使用 mybatis 进行开发了。

==== Mapper 接口

Mapper 接口可以放在项目 package ( `com.mycompany.myapp` ) 下的任意目录中，veigar 通过
`@Mapper` 注解来识别 Mapper 接口：

[source, java]
----
@Mapper       // <1>
public interface TestMapper {
    int insertTest(Test test);
}
----
<1> `@Mapper` 注解

==== Mapper XML 映射文件

映射文件 *必须* 放在 src/main/resources/mybatis/mapper 文件夹下：

----
├── myapp
|   ├── src
|   |   └── main
|   |       ├── java
|   |       └── resources
|   |           └── mybatis
|   |               └── mapper
|   |                   ├── Test1Mapper.xml
|   |                   └── Test2Mapper.xml
│   └── pom.xml
----
