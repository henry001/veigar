= Veigar
watertao <1059912278@qq.com>
:toc: left
:toclevels: 3
:source-highlighter: coderay
:sectnums:
:icons: font

:sectnumlevels: 3

一个用于开发 RESTful 接口的脚手架，基于 spring boot。

== 快速入门

=== 新建一个 Maven 项目

----
├── myapp
|   ├── src
|   |   └── main
|   |       ├── java
|   |       |   └── com
|   |       |       └── mycompany
|   |       |           └── BootstrapApplication.java
|   |       └── resources
|   |           └── application.properties
│   └── pom.xml
----

=== pom.xml

在 pom.xml 中引入 veigar 有两种方式：

==== 继承 veigar-parent

.pom.xml
[source, xml]
----
<parent>                                <!--1-->
  <groupId>io.github.watertao</groupId>
  <artifactId>veigar-parent</artifactId>
  <version>2.1.1-SNAPSHOT</version>
</parent>
<groupId>com.mycompy</groupId>
<artifactId>myapp</artifactId>
<version>1.0.0-SNAPSHOT</version>
----
<1> 继承 `veigar-parent`

==== 依赖 veigar-core

如果项目需要依赖其他 parent，无法依赖 `veigar-parent` ，那么可以通过以下方式达到同样的效果：

.pom.xml
[source, xml]
----
<groupId>com.mycompy</groupId>
<artifactId>myapp</artifactId>
<version>1.0.0-SNAPSHOT</version>
<dependencies>
  <dependency>                          <!--1-->
    <groupId>io.github.watertao</groupId>
    <artifactId>veigar-core</artifactId>
  </dependency>
</dependencies>
<build>
  <plugins>
    <plugin>                            <!--2-->
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-maven-plugin</artifactId>
    </plugin>
  </plugins>
</build>
----
<1> 依赖 `veigar-core`
<2> 添加插件 `spring-boot-maven-plugin`

=== BootstrapApplication.java

.BootstrapApplication.java
[source, java]
----
@SpringBootApplication(
   scanBasePackages={
      "com.mycompany",                  // <1>
      "io.github.watertao.veigar"
   }
)
public class BootstrapApplication {
   public static void main(String[] args) {
      SpringApplication.run(BootstrapApplication.class, args);
   }
}
----
<1> `@SpringBootApplication` 注解中 `scanBasePackages` 需要添加自己的项目 package，以及
 `io.github.watertao.veigar` ，这会告诉 spring 去扫描位于这些 package 下的 class 以便注册 bean。

[NOTE]
====
需要注意的是，`scanBasePackages` 中自己项目的 package 需要尽量设置到公司级别，比如上例中的
`com.mycompany` ，因为这会影响到组件的扫描范围。
====

=== application.properties

.application.properties
[source, properties]
----
spring.profiles.active = dev            # <1>
app.basePackage = com.mycompany.myapp   # <2>
server.port = 8080                      # <3>
cors.allowedOrigins = *                 # <4>
----
<1> 开发环境下设置为 `dev`， 生产环境下设置为 `prod`
<2> 项目级别的 package（公司级别下一级），某些组件需要读取并使用这个参数
<3> 服务端口
<4> CORS 允许的来源

=== 第一个接口

创建 src/main/java/com/mycompany/myapp/controller/TestController.java

.TestController.java
[source, java]
----
@RestController                         // <1>
public class TestController {
    @GetMapping("/test")                // <2>
    public Object test() {
        Map map.put("a", "b");
        return map;
    }
}
----
<1> 每个 RESTful 接口类都需要使用 `@RestController` 注解
<2> 每个 RESTful 接口方法都需要使用 `@RequestMapping` 或其子注解

=== 启动项目

通过执行 `spring-boot-maven-plugin` 启动项目：

[source, shell]
----
mvn spring-boot:run
----


== 设计理念

veigar 是在 spring boot 的基础上进一步封装了在开发 RESTful 接口时常用的一些特性，用于简化开发框架的搭建过程。 +
目前 veigar 支持的组件包括：

[cols="1,2,1", options="header"]
|===
|组件名
|作用
|依赖

|*veigar-parent*
|用于简化 pom.xml 中对 veigar 的依赖
|

|*veigar-core*
|核心组件
|

|*veigar-session*
|若项目具有用户会话的概念，就需要用到此组件。而此组件一般不单独依赖，还需要额外依赖一个 veigar-session-* 来指定会话持久化到哪里
|veigar-core

|*veigar-session-map*
|将会话保存在内存 Map 中
|veigar-session

|*veigar-session-redis*
|将会话保存在 redis 中
|veigar-session

|*veigar-db*
|若项目需要进行数据库访问，可以依赖此组件
|veigar-core

|*veigar-auth*
|提供了用户认证相关的扩展点
|veigar-session

|*veigar-audit-log*
|提供了用户日志审计相关的扩展点
|veigar-session

|===


== 特性

=== 基本 RESTful 支持

==== query parameter 获取

.HTTP REQUEST
----
GET /users?name=watertao HTTP/1.1
----

.controller
[source, java]
----
@GetMapping("/users")
public void test(
  @RequestParam("name") String name       // <1>
) {
    // name = "watertao";
}
----
<1> 使用 `@RequestParam` 获取 query parameter

==== path variable 获取

.HTTP REQUEST
----
GET /users/133 HTTP/1.1
----

.controller
[source, java]
----
@GetMapping("/users/{userId}")              // <1>
public void test(
  @PathVariable("userId") Integer userId    // <2>
) {
    // userId = 133;
}
----
<1> URI 的定义中需要指定 path variable 参数名，本例中为 `{userId}`
<2> 使用 `@PathVariable` 获取 path variable, 注解的参数需要与 URI 中 `{userId}` 内的定义相对应


==== request body 获取

.HTTP REQUEST
----
POST /users HTTP/1.1
Content-Type: application/json;charset=UTF-8

{
  "name": "watertao"
}
----

.controller
[source, java]
----
@PostMapping("/users")
public void test(
  @RequestBody User user                    // <1>
) {
    // user.getName() = "watertao"
}
----
<1> 使用 `@RequestBody` 注解告诉 spring boot 将 JSON 反序列化为对象

.User
[source, java]
----
public class User {
    private String name;
    public String getName() {...}
    public void setName(String name) {...}
}
----

==== Content-Type

veigar 只支持 JSON 格式，且字符集为 UTF-8 的请求。  +
所以，客户端在发起 RESTful 请求调用时，若请求体中包含了 JSON，则必须设置 `Content-Type` ：

.HTTP REQUEST
----
POST /users HTTP/1.1
Content-Type: application/json;charset=UTF-8

{ ... }
----


==== 请求校验

veigar 集成了 Hibernator-validator 作为 bean validation 的实现。所以我们可以很方便的对请求体中的 JSON 进行验证。

.User.java
[source, java]
----
public class User {
    @NotEmpty
    private String name;                    // <1>

    public String getName() {...}

    public void setName(String name) {...}
}
----
<1> 通过注解 `@NotEmpty` 确保 `name` 属性不可为空


.controller
[source, java]
----
@PostMapping("/users")
public Object test(
  @Valid @RequestBody User user             // <1>
) {

}
----
<1> 通过添加注解 `@Valid` 告知 spring boot 对 `user` 对象进行校验，若 JSON 中 name 属性为空，则会抛出校验异常
